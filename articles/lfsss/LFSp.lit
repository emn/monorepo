@title LFS: a primer

@s introduction
in my experience, many network engineers lack an intuition about what linux is and how it works, despite its increasing importance in our field.
counting myself among them, i set out to deepen my understanding.
the foremost resource for that purpose is Linux From Scratch, but after skimming through the book, i felt that i first needed a higher level overview of the material.
this article is the first in a series designed to supplement LFS.

if you'd like to follow along, i suggest a clean install of ubuntu 22.04.3 LTS.

--- setup
sudo apt install --yes qemu-system-x86-64 libguestfs-tools build-essential git bison flex libelf-dev libssl-dev libncurses5-dev
mkdir LFSp && cd "$_"
---

we first install the required packages.
those important to know will be discussed further on.
we'll also create a working directory for the sake of tidiness, and change into it.

@s stage0 - running a linux kernel
linux is a type of computer program called a kernel.
a kernel manages resources (e.g. RAM), and provides an interface through which applications can use them.
despite what you may have read, linux is not an operating system; what that means in practice will become clear shortly.
when a linux system boots, the kernel is loaded into memory from a compressed image on disk.
that image, along with everything else required at boot time, can by convention be found in the /boot directory.

<pre>
$ ls -hal /boot
total 302M
drwxr-xr-x  4 root root   19 Dec 30 06:28 .
drwxr-xr-x 19 root root   25 Dec 28 22:46 ..
-rw-r--r--  1 root root 270K Jul 13 14:22 config-6.2.0-26-generic
-rw-r--r--  1 root root 270K Nov 16 09:48 config-6.2.0-39-generic
drwxr-xr-x  4 root root 4.0K Jan  1  1970 efi
drwxr-xr-x  5 root root 4.0K Dec 30 06:26 grub
lrwxrwxrwx  1 root root   27 Dec 30 06:26 initrd.img -> initrd.img-6.2.0-39-generic
-rw-r--r--  1 root root 139M Dec 30 06:24 initrd.img-6.2.0-26-generic
-rw-r--r--  1 root root 132M Dec 30 06:28 initrd.img-6.2.0-39-generic
lrwxrwxrwx  1 root root   27 Dec 28 22:43 initrd.img.old -> initrd.img-6.2.0-26-generic
-rw-r--r--  1 root root 179K Feb  6  2022 memtest86+.bin
-rw-r--r--  1 root root 181K Feb  6  2022 memtest86+.elf
-rw-r--r--  1 root root 181K Feb  6  2022 memtest86+_multiboot.bin
-rw-------  1 root root 7.6M Jul 13 14:22 System.map-6.2.0-26-generic
-rw-------  1 root root 7.7M Nov 16 09:48 System.map-6.2.0-39-generic
lrwxrwxrwx  1 root root   24 Dec 30 06:26 vmlinuz -> vmlinuz-6.2.0-39-generic
-rw-r--r--  1 root root  14M Aug  8 00:05 vmlinuz-6.2.0-26-generic
-rw-r--r--  1 root root  14M Nov 16 09:50 vmlinuz-6.2.0-39-generic
lrwxrwxrwx  1 root root   24 Dec 30 06:26 vmlinuz.old -> vmlinuz-6.2.0-26-generic
</pre> 

in our case the kernel image currently in use is `vmlinuz-6.2.0-39-generic`.
(if you are curious about the filename, it is an abbreviation of "Virtual Memory Linux Gzip", another convention)
check its permissions and ensure that it is readable as above, otherwise we will run into problems.


having found the linux kernel image used by our currently running system, what do you suppose happens if we boot it?
to find out, we'll use a program called qemu.

--- stage0 boot
qemu-system-x86_64 -m 512M -kernel /boot/vmlinuz
---

`qemu-system-x86_64` is an emulator for PC systems (that is, [IBM PC compatible](https://en.wikipedia.org/wiki/IBM_PC_compatible#The_IBM_PC_compatible_today) systems) based on the AMD64 architecture - qemu can emulate many platforms, but this is what we will use because of its ubiquity.
we give it some memory with the `-m` flag, and it will very kindly load our kernel for us directly, allowing us to sidestep the hassle of creating a bootable disk image (for now).
in the new window that appears you will see rapidly scrolling output as the kernel initializes, which stops just as rapidly when the kernel "panics" (crashes).
so, we have answered our earlier question - when we run a linux kernel directly, it crashes almost immediately.
let's explore why that is, and what we can do about it.

@s stage1 - mounting a root filesystem

<pre>
[    1.949579] Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)
</pre>

the kernel is letting us know that it can't boot without a filesystem.
it does not tell us why, but to be fair, inside the error emitted during a kernel panic is hardly the time or place.
we will find out why soon enough; for now, we need to tell our kernel on which device the root filesystem can be found; to do so we pass it the [boot parameter](https://man7.org/linux/man-pages/man7/bootparam.7.html) `root=`.
let's create a disk image to provide to qemu, which will make it available for our linux kernel to use.
there are many ways to do this, but the tool `virt-make-fs` works well and abstracts away the details, so we'll use it.

--- create rootfs
mkdir rootfs
virt-make-fs --format=qcow2 --type=ext2 rootfs rootfs.ext2.qcow2
---

we make a directory `rootfs` and use `virt-make-fs` to create a qcow2 disk image, on which is an ext2 filesystem containing the contents of the aformentioned directory (currently, nothing).
now we can try booting again:

--- stage1 boot
qemu-system-x86_64 -m 512M -kernel /boot/vmlinuz -hda rootfs.ext2.qcow2 -append "root=/dev/sda"  
---

`-hda` attaches the image file we created to our linux kernel as a SCSI device.
`-append` passes parameters to the kernel, and in this case it sets the value of `root=` to `/dev/sda`.
`/dev/sda` is a path representing the first SCSI device attached to the system; subsequent devices are named sdb, sdc, and so on.

exeuting this command, we hit a different panic.

@s stage2 - executing an init program

<pre>
[    1.966493] Kernel panic - not syncing: No working init found.  Try passing init= option to kernel. See Linux Documentation/admin-guide/init.rst for guidance.
</pre>

the kernel found our root filesystem, and looked there unsuccessfully for a program called `init`.
`init` is a user level program which the kernel executes as the final step of initialization. 
let's create our own example init program and see if our linux kernel will run it.

--- create simple init
mkdir rootfs/sbin
gcc -static -o rootfs/sbin/init -x c - << EOF
#include <stdio.h>
#include <unistd.h>

void main() {
    while(1){
      printf("Hello, World!\n");
      sleep(1);
    }
}
EOF
virt-make-fs --format=qcow2 --type=ext2 rootfs rootfs.ext2.qcow2
---

this is a simple C program that will print "Hello, World!" every second in an infinite loop.
the details of the program and how it is compiled are not important for our purposes, save two points.
firstly that we have written the program as an infinite loop quite deliberately - what do you suppose would have happened if we hadn't?
and secondly that we have built the program statically, meaning that its dependencies are included in the resulting binary - it does not require access to any shared libraries, which is good, because it is currently the only file on our disk.

+we make a directory called `sbin` because that is the first place linux looks for an `init` program; alternatively we could provide the `init=` parameter to tell the kernel what the program is called and where on our root filesystem it is located.
we also need to remember to recreate our rootfs disk image with `virt-make-fs` now that we've modified the directory it is built from.

--- stage2 boot
qemu-system-x86_64 -m 512M -kernel /boot/vmlinuz -hda rootfs.ext2.qcow2 -append "root=/dev/sda"
---

granted, it's not very useful, but at least it hasn't crashed - we finally have our linux kernel running.
i hope you can see now that it is not (only) pedantry that drives some to insist on linux' status as "just" a kernel and not an OS; the distinction is an important one.
building an operating system with the linux kernel at the centre is the job of distributions, and the focus of the LFS book, so we won't explore it here.
instead: qemu has been giving us quite a leg up by running our kernel directly for us, and that's not cricket.

@s stage3 - booting from disk with UEFI

you likely know what a BIOS is and does; you may not know that almost no modern computers ship with a BIOS - they now use UEFI.
these are in fact entirely different things, although some people mistakenly (but understandably) believe that BIOS is a generic term, and that UEFI is a "type of" BIOS.
we will only cover the minimum we need to know to get our system running using qemu's UEFI firmware, which is called OVMF.
there are four major concepts we need to understand:

UEFI applications
these are just programs that have been written in a particular way, such that they can be executed by UEFI firmware.
boot loaders are an example of the sort of program that would be written in this way; much like how a linux kernel runs and hands off control to `init`, UEFI can execute a boot loader program, which will then handle starting your OS.

EFI system partition

GUID partition table

UEFI boot manager
this is the program, included in implementations of UEFI, that is responsible for (among other things) loading UEFI applications.
the boot manager is configurable via "boot options", which describe on what partition and at what filepath UEFI applications can be found.

we now know what we need to do: create a new GPT-partitioned disk image, create a FAT-formatted EFI system partition on the disk, write a UEFI application that will boot our linux image, copy it to the ESP, write a boot option describing the location of the application and provide it to the OVMF boot manager.
needless to say, this is quite a lot of work.

--- create efi structure
mkdir --parents rootfs/EFI/BOOT
cp /boot/vmlinuz rootfs/EFI/BOOT/BOOTx64.EFI
virt-make-fs --format=qcow2 --type=fat rootfs rootfs.fat.qcow2
---

so let's cheat.
in the absence of any valid boot option, the boot manager will enumerate all devices and attempt to boot from each, using the default path `\EFI\BOOT\BOOT[machine type short-name].EFI`
the UEFI specification [states](https://uefi.org/specs/UEFI/2.10/02_Overview.html): "An UEFI-defined System Partition is required by UEFI to boot from a block device"
happily for us, however, OVMF will find and execute `BOOTx64.EFI` on any FAT filesystem - it does not require the image to be on an ESP, nor even that the filesystem be partitioned at all.
we'll take advantage of that fact and skip creating an ESP for now - it will be covered in detail in the next article in this series.

you might be surprised to see that we can just rename our kernel image and have UEFI boot it - does this mean that linux is a UEFI application?
if compiled with the configuration option CONFIG_EFI_STUB enabled, yes; this is called the [EFI Boot Stub](https://docs.kernel.org/admin-guide/efi-stub.html) and it has saved us a great deal of effort.

as complex as this seemed at first, in practice all we've needed to do is rename our kernel image and store it in a particular location on a FAT formatted disk image.
now we can boot it:

--- stage3 boot
qemu-system-x86_64 -m 512M -bios /usr/share/qemu/OVMF.fd -hda rootfs.fat.qcow2
---

attentive readers will have already spotted the problem.

@s stage4 - creating an initramfs
now that qemu is no longer booting our kernel for us, it can't pass along the required boot parameter.
the uefi firmware is able to find and boot our kernel image from the disk we provided, but we are again seeing a panic because the kernel doesn't know on what device to find the root filesystem.
we have a few options to fix this, but instead we will take this opportunity to introduce another method by which linux can boot: initramfs.

--- create initramfs
mkdir --parents initramfs/EFI/BOOT
cp rootfs/EFI/BOOT/BOOTx64.EFI initramfs/EFI/BOOT/vmlinuz.EFI
(
cd rootfs/sbin
echo init | cpio --quiet --create --format=newc | gzip > ../../initramfs/initramfs_data.cpio.gz
)
---

we'll create a new directory for our initramfs, and give it that same structure that UEFI expects.
cpio reads a list of filenames from stdin and creates an archive containing them.
we then compress the archive with gzip and put it in the initramfs directory.

--- create initramfs +=
cat << EOF > initramfs/startup.nsh
vmlinuz.efi initrd=initramfs_data.cpio.gz
EOF
virt-make-fs --format=qcow2 --type=fat initramfs initramfs.fat.qcow2
---

unfortunately, we still need to pass a parameter to the kernel, this time to tell it where the initramfs file is.
we can do this from the UEFI firmware shell, but having to do that manually on every boot would be inconvenient.
we needn't bother partitioning our disk, as our UEFI firmware will look for bootx64.efi on any FAT filesystem.

--- stage4 boot
qemu-system-x86_64 -m 512M -bios /usr/share/qemu/OVMF.fd -hda initramfs.fat.qcow2 -net none
---

this works, but it is a bit of a hack. we should not be relying on startup.nsh to pass kernel parameters on boot.
we use `-net none` here just because the UEFI firmware will attempt a network boot, and we don't want to have to wait for that to time out. 


@s stage5 - building a custom kernel
its time now to build our own kernel, into which we can embed our initramfs.

clone the linux kernel git repository
--- build kernel
git clone --depth 1 git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git
---
we use `--depth 1` to create a shallow clone, pulling only the latest commit and not the entire history

--- build kernel +=
cp rootfs/sbin/init linux/usr/
cat << EOF > linux/usr/initramfs_list
dir /dev 0755 0 0
nod /dev/console 0600 0 0 c 5 1
file /init usr/init 500 0 0
EOF

(
cd linux
make mrproper
make defconfig
scripts/config --set-str CONFIG_INITRAMFS_SOURCE usr/initramfs_list
scripts/config --enable CONFIG_CMDLINE_BOOL
scripts/config --set-str CONFIG_CMDLINE console=ttyS0
scripts/config --enable CONFIG_DRM_BOCHS
make olddefconfig
make -j "$(nproc)" --quiet
)

cp linux/arch/x86/boot/bzImage initramfs/EFI/BOOT/BOOTx64.EFI
virt-make-fs --format=qcow2 --type=fat initramfs initramfs.fat.qcow2
---
make olddefconfig updates our config with the new values we set, and also sets new symbols to their default value without prompting

--- stage5 boot
qemu-system-x86_64 -m 512M -bios /usr/share/qemu/OVMF.fd -hda initramfs.fat.qcow2 -nographic
---

we now have to use `-nographic` because our custom linux kernel has not been built with support for graphics.
we are now successfully booting linux from disk via UEFI and running our custom init program from an initramfs!
exercise for the reader: make the output visible without -nographic

@s stage6 - busybox
it's about time we set aside our example init program and installed something more useful. a great option for a minimal init is busybox. download a static binary from busybox.net

--- busybox initramfs
(
cd linux
mkdir -p usr/initramfs_data/bin
cp ~/Downloads/busybox usr/initramfs_data/bin/
chmod +x usr/initramfs_data/bin/busybox

cat << EOF > usr/initramfs_data/init
#!/bin/busybox sh
/bin/busybox --install -s /bin/
exec sh
EOF
chmod +x usr/initramfs_data/init

cat << EOF > usr/initramfs_list
dir /dev 0755 0 0
nod /dev/console 0600 0 0 c 5 1
dir /bin 755 1000 1000
file /bin/busybox usr/initramfs_data/bin/busybox 755 0 0
slink /bin/sh busybox 777 0 0
file /init usr/initramfs_data/init 500 0 0
EOF
make -j "$(nproc)"
)

cp linux/arch/x86/boot/bzImage initramfs/EFI/BOOT/BOOTx64.EFI
virt-make-fs --format=qcow2 --type=fat initramfs initramfs.fat.qcow2
---

--- stage6 boot
qemu-system-x86_64 -m 512M -bios /usr/share/qemu/OVMF.fd -hda initramfs.fat.qcow2 -nographic
---

now we finally have a useful system.
exercise for the reader: create a bootable usb

@ stage7 - switch_root

--- exec switch_root
(
cd linux

cat << EOF > usr/initramfs_data/init
#!/bin/busybox sh
/bin/busybox --install -s /bin/
mount -t proc proc /proc
mount -t sysfs sysfs /sys
mdev -s
mount /dev/sdb /mnt
exec switch_root /mnt /sbin/init
EOF
chmod +x usr/initramfs_data/init

cat << EOF > usr/initramfs_list
dir /proc 755 0 0
dir /sys 755 0 0
dir /mnt 755 0 0
dir /dev 0755 0 0
nod /dev/console 0600 0 0 c 5 1
dir /bin 755 1000 1000
file /bin/busybox usr/initramfs_data/bin/busybox 755 0 0
slink /bin/sh busybox 777 0 0
file /init usr/initramfs_data/init 500 0 0
EOF
make -j "$(nproc)"
)
cp linux/arch/x86/boot/bzImage initramfs/EFI/BOOT/BOOTx64.EFI
virt-make-fs --format=qcow2 --type=fat initramfs initramfs.fat.qcow2
virt-make-fs --format=qcow2 --type=ext2 rootfs rootfs.ext2.qcow2
---

--- stage7 boot
qemu-system-x86_64 -m 512M -bios /usr/share/qemu/OVMF.fd -hda initramfs.fat.qcow2 -hdb rootfs.ext2.qcow2 -nographic
---

exercise for the reader: create one disk with two partitions containing our initramfs and rootfs respectively.

now we are ready to begin Linux From Scratch!





write more detailed explanations
https://www.landley.net/writing/rootfs-intro.html
https://www.happyassassin.net/posts/2014/01/25/uefi-boot-how-does-that-actually-work-then/
https://superuser.com/questions/1657478/how-make-a-bootable-iso-for-my-uefi-application-bare-bones
https://stackoverflow.com/questions/57389189/create-pure-uefi-bootable-iso-from-directory

--- LFSp.sh --- noWeave
#!/bin/bash
set -o errexit
set -o nounset
set -o pipefail

# ========== BASHLOG ==========
@{bashlog}
DEBUG=1
# ========== BASHLOG ==========

final_stage=stage7

log info "Preparing environment..."
@{setup}

log info "Building stage0"
log debug "test"
(
mkdir stage0 && cd "$_"
cat << EOF > boot.sh
@{stage0 boot}
EOF
chmod +x boot.sh
)

log info "Building stage1"
(
mkdir stage1 && cd "$_"

@{create rootfs}
cat << EOF > boot.sh
@{stage1 boot}
EOF
chmod +x boot.sh
)

log info "Building stage2"
(
cp -r stage1 stage2 && cd "$_"

@{create simple init}
cat << EOF > boot.sh
@{stage2 boot}
EOF
chmod +x boot.sh
)

log info "Building stage3"
(
cp -r stage2 stage3 && cd "$_"

@{create efi structure}
cat << EOF > boot.sh
@{stage3 boot}
EOF
chmod +x boot.sh
)

log info "Building stage4"
(
cp -r stage3 stage4 && cd "$_"

@{create initramfs}
cat << EOF > boot.sh
@{stage4 boot}
EOF
chmod +x boot.sh
)

log info "Building stage5"
#change copy strategy from here to avoid whole-kernel rebuilds
(
cp -r stage4 ${final_stage} && cd "$_"

@{build kernel}
cat << EOF > boot.sh
@{stage5 boot}
EOF
chmod +x boot.sh
)
cp -r ${final_stage} stage5

log info "Building stage6"
(
cd ${final_stage}

@{busybox initramfs}
cat << EOF > boot.sh
@{stage6 boot}
EOF
chmod +x boot.sh
)
cp -r ${final_stage} stage6

log info "Building stage7"
(
cd stage7

@{exec switch_root}
cat << EOF > boot.sh
@{stage7 boot}
EOF
chmod +x boot.sh
)

#scripts/config --set-val INITRAMFS_ROOT_UID 0
#scripts/config --set-val INITRAMFS_ROOT_GID 0
#scripts/config --enable INITRAMFS_COMPRESSION_GZIP
#scripts/config --disable INITRAMFS_COMPRESSION_BZIP2
#scripts/config --disable INITRAMFS_COMPRESSION_LZMA
#scripts/config --disable INITRAMFS_COMPRESSION_XZ
#scripts/config --disable INITRAMFS_COMPRESSION_LZO
#scripts/config --disable INITRAMFS_COMPRESSION_LZ4
#scripts/config --disable INITRAMFS_COMPRESSION_ZSTD
#scripts/config --disable INITRAMFS_COMPRESSION_NONE
#scripts/config --disable CMDLINE_OVERRIDE
---

--- bashlog --- noWeave
function _log_exception() {
  (
    BASHLOG_FILE=0;
    BASHLOG_JSON=0;
    BASHLOG_SYSLOG=0;

    log 'error' "Logging Exception: ${@}";
  );
}

function log() {
  local date_format="${BASHLOG_DATE_FORMAT:-+%F %T}";
  local date="$(date "${date_format}")";
  local date_s="$(date "+%s")";

  local file="${BASHLOG_FILE:-0}";
  local file_path="${BASHLOG_FILE_PATH:-/tmp/$(basename "${0}").log}";

  local json="${BASHLOG_JSON:-0}";
  local json_path="${BASHLOG_JSON_PATH:-/tmp/$(basename "${0}").log.json}";

  local syslog="${BASHLOG_SYSLOG:-0}";
  local tag="${BASHLOG_SYSLOG_TAG:-$(basename "${0}")}";
  local facility="${BASHLOG_SYSLOG_FACILITY:-local0}";
  local pid="${$}";

  local level="${1}";
  local upper="$(echo "${level}" | awk '{print toupper($0)}')";
  local debug_level="${DEBUG:-0}";

  shift 1;

  local line="${@}";

  # RFC 5424
  #
  # Numerical         Severity
  #   Code
  #
  #    0       Emergency: system is unusable
  #    1       Alert: action must be taken immediately
  #    2       Critical: critical conditions
  #    3       Error: error conditions
  #    4       Warning: warning conditions
  #    5       Notice: normal but significant condition
  #    6       Informational: informational messages
  #    7       Debug: debug-level messages

  local -A severities;
  severities['DEBUG']=7;
  severities['INFO']=6;
  severities['NOTICE']=5; # Unused
  severities['WARN']=4;
  severities['ERROR']=3;
  severities['CRIT']=2;   # Unused
  severities['ALERT']=1;  # Unused
  severities['EMERG']=0;  # Unused

  local severity="${severities[${upper}]:-3}"

  if [ "${debug_level}" -gt 0 ] || [ "${severity}" -lt 7 ]; then

    if [ "${syslog}" -eq 1 ]; then
      local syslog_line="${upper}: ${line}";

      logger \
        --id="${pid}" \
        -t "${tag}" \
        -p "${facility}.${severity}" \
        "${syslog_line}" \
        || _log_exception "logger --id=\"${pid}\" -t \"${tag}\" -p \"${facility}.${severity}\" \"${syslog_line}\"";
    fi;

    if [ "${file}" -eq 1 ]; then
      local file_line="${date} [${upper}] ${line}";
      echo -e "${file_line}" >> "${file_path}" \
        || _log_exception "echo -e \"${file_line}\" >> \"${file_path}\"";
    fi;

    if [ "${json}" -eq 1 ]; then
      local json_line="$(printf '{"timestamp":"%s","level":"%s","message":"%s"}' "${date_s}" "${level}" "${line}")";
      echo -e "${json_line}" >> "${json_path}" \
        || _log_exception "echo -e \"${json_line}\" >> \"${json_path}\"";
    fi;

  fi;

  local -A colours;
  colours['DEBUG']='\033[34m'  # Blue
  colours['INFO']='\033[32m'   # Green
  colours['NOTICE']=''         # Unused
  colours['WARN']='\033[33m'   # Yellow
  colours['ERROR']='\033[31m'  # Red
  colours['CRIT']=''           # Unused
  colours['ALERT']=''          # Unused
  colours['EMERG']=''          # Unused
  colours['DEFAULT']='\033[0m' # Default

  local norm="${colours['DEFAULT']}";
  local colour="${colours[${upper}]:-\033[31m}";

  local std_line="${colour}${date} [${upper}] ${line}${norm}";

  # Standard Output (Pretty)
  case "${level}" in
    'info'|'warn')
      echo -e "${std_line}";
      ;;
    'debug')
      if [ "${debug_level}" -gt 0 ]; then
        echo -e "${std_line}";
      fi;
      ;;
    'error')
      echo -e "${std_line}" >&2;
      if [ "${debug_level}" -gt 0 ]; then
        echo -e "Here's a shell to debug with. 'exit 0' to continue. Other exit codes will abort - parent shell will terminate.";
        bash || exit "${?}";
      fi;
      ;;
    *)
      log 'error' "Undefined log level trying to log: ${@}";
      ;;
  esac
}

#declare prev_cmd="null";
#declare this_cmd="null";
#trap 'prev_cmd=$this_cmd; this_cmd=$BASH_COMMAND' DEBUG \
#  && log debug 'DEBUG trap set' \
#  || log error 'DEBUG trap failed to set';
---
